## 讨论1的个人理解与解答
### 题1
1.1 正确

```
是的，即使两个比特位完全相同，也可能代表不同的结果。比如97在int类型下解释为整数97，但是在char类型下解释为字符‘a’。如何解释完全取决于你赋予他什么含义（当然我们一般会遵守一些共同规则），比如在代码可以用1代表你想代表的任何东西，当然你也可以用其他数字。赋予其实际含义，其就有不同的结果
```

1.2 错误

```
在补码中，一个正数加上一个负数是不会溢出的。可以进行分类讨论：
1.若正数大于负数的绝对值，则正数+负数结果会是一个正数（此时会产生最高位进位，进的位和负数最高位1合并，会再进位截断，然后当前最高位为0了，因此结果是一个正数，不会溢出）
2.若正数小于负数的绝对值，则正数+负数结果会是一个负数（此时不会产生进位，因此更不可能产生溢出了）
```
1.3 错误
```
负数最高位（MSB）为1，正数最高位为0，解释为无符号整数的值会更大
```
1.4 正确
```
移码可以看成是平移，将最小的数平移到0.因此将其解释为无符号整数的时候，负数会解释的更小。例如-128~127，可以平移成0~256.
```
### 题2
#### (a)

1 `0b1001 0011 = 147 = 0x93`
2 `63 = 0b0011 1111 = 0x3F`
3 `0b0010 0100 = 36 = 0x24`
4 `0 = 0b0 = 0x0`
5 `39 = 0b0010 0111 = 0x27`
6 `437 = 0b0001 1011 0101 = 0x1B5`
7 `0x0123 = 0b0000 0001 0010 0011 = 291`

#### (b)

1 `0xD3AD = 0b1101 0011 1010 1101`
2 `0xB33F = 0b1011 0011 0011 1111`
3 `0x7EC4 = 0b0111 1110 1100 0100`

#### (c）

1 2^16^=2^6^Ki
2 2^27^=2^7^Mi
3 2^43^=2^3^Ti
4 2^36^=2^6^Gi
5 2^34^=2^4^Gi
6 2^61^=2Ei
7 2^47^=2^7^Ti
8 2^59^=2^9^Pi

#### (d)

1 2Ki=2^10^
2 512Ki=2^19^
3 16Mi=2^24^
4 256Pi=2^58^
5 64Gi=2^36^
6 128Ei=2^67^

### 题3

#### (a)
1. 最大的无符号整数是**255**，加1后为**0**
2. 最大的移码整数是**128**，加1后为**-127**
3. 最大的补码整数是**127**，加1后为**-128**

#### (b)
1. 无符号整数中：0b0 代表 0，0b1 代表 1 ，没有-1
2. 移码中：127的二进制数 0b0111111 代表0，128的二进制数0b10000000代表1， 126的二进制数 0b111110 代表-1
3. 补码中: 0b0代表0 ，0b1代表1，0b11111111代表-1

#### (c)
1. 无符号整数中: 0b0001 0001代表17，没有-17
2. 移码中：0b1001 0000 代表17，0b0110 1110 代表-17
3. 补码中：0b0001 0001 代表17,  0b1110 1111 代表-17

#### (d)

没有，因为我们可以任意映射，比如将原先映射的0~255变成映射1~256等等

#### (e)

$$
\begin{align}
&只需要证明\space x+\bar x+1=0\space即可;其中 \bar x代表x所有比特位取反\\
&显然 x+ \bar x=0b 1111 1111 (对于高于8位的数也一样)\\
&因此 x+ \bar x+1=0\\
\end{align}
$$

#### (f)

1.10进制数：优点是人比较熟悉10进制数，缺点是计算机不熟悉
2.2进制数：计算机熟悉，方便设计电路，人不熟悉，表达很大的数的时候一长串
3.16进制数：是2的4次幂，因此很容易由2进制转变，同时表达大数不会像2进制数那么长。

### 题4
#### (a)
1. 0b011001-0b000111=0b010010=18 两个正数相减，不会溢出
2. 0b100011+0b111010=0b011101 溢出，两个负数相加变为正数了
0b100011=-0b011101=-29
0b111010=-0b000110=-6
因此答案位-35，而6位补码，最高是-2^5^=-32。因此溢出了
3. 0x3B+0x06=0x41=0b*01*00 0001 可以看到高位截断了.
0x3B=0b11 1011=-0b000101=-5
0x06=0b00 0110=6
故0x3B+0x06=0b000001=1
负数+正数结果位正数,成立,此时是不会溢出的
4. 0xFF-0XAA=0b11 1111-0b10 1010,可以看到两个数都是负数,相减不会溢出 
同时问题有问题,在6位下,不可能出现0xFF和0xAA

#### (b)
1. 8bit的无符号整数范围是0~255,因此0~256需要9bit
2. -7到56总共有64个数字,因此需要6bit
3. 64\~127有64个数字,需要6bit,-127~-64一样需要6bit,两个一起则需要7bit就可以
4. 12TiB=12\*2^40^,因此最少需要44bit位